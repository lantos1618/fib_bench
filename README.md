# 🧮 Fibonacci Benchmark Project

This project explores the implementation and performance characteristics of the Fibonacci sequence calculation across different approaches, with a particular focus on comparing various programming paradigms and languages.

## 🎯 Purpose

The main goal of this project is to analyze and compare the performance of different Fibonacci sequence implementations:

1. 🔄 Recursive Implementation
2. ⚡ Iterative (Loop-based) Implementation
3. 🧠 Memoization-based Implementation

The main focus is to have idiomatic implementations in each language. We can acknowledge that you can golf and golf but we want to see how fast you can go with just a straightforward implementation with the use of LLMs.

## 🛠️ Implementation Details

The project implements the Fibonacci sequence calculation using different approaches to compare:
- ⏱️ Time complexity
- 💾 Space complexity
- 🚀 Execution speed
- 📊 Memory usage patterns

## 💻 Languages

The implementations are tested across different programming languages, with a special focus on:
- 🐎 Pony (an actor-model based language)
- 👑 Nim (a systems programming language)
- 🦀 Rust (a systems programming language)
- ⚡️ Zig (a systems programming language)
- 👴 C (a low-level language)
- 🐍 Python (a high-level language)
- 🐹 Go (a high-level language)
- ⭐ Gleam (a high-level language)

## 📈 Benchmarking

The project includes benchmarking suites to measure and compare:
- ⚡ Execution time
- 🧮 Memory consumption
- 🔋 CPU utilization
- 📊 Performance characteristics at different input scales

## 🎯 Goals

1. 📊 Compare the efficiency of different Fibonacci implementation approaches
2. 🔍 Explore the strengths and limitations of various programming languages
3. 🧪 Analyze how different programming paradigms affect performance
4. 💡 Provide insights into optimization techniques across languages

## 📝 Results

(Results and performance comparisons will be added as benchmarks are completed)
